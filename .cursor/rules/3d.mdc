---
alwaysApply: false
---

3d Models
üìê –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –ü–†–ê–í–ò–õ–ê –î–õ–Ø ROUNDED VOXELS:
1. –ë–∞–∑–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω–æ–≥–æ –≤–æ–∫—Å–µ–ª—è:
javascript// –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø - –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–π –µ—ë!
function createRoundedBox(width, height, depth, radius, smoothness) {
    const shape = new THREE.Shape();
    const x = width / 2 - radius;
    const y = height / 2 - radius;
    
    // –†–∏—Å—É–µ–º –ø—Ä–æ—Ñ–∏–ª—å —Å –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–º–∏ —É–≥–ª–∞–º–∏
    shape.moveTo(-x, -y);
    shape.lineTo(x, -y);
    shape.quadraticCurveTo(x + radius, -y, x + radius, -y + radius);
    shape.lineTo(x + radius, y - radius);
    shape.quadraticCurveTo(x + radius, y, x, y);
    shape.lineTo(-x, y);
    shape.quadraticCurveTo(-x - radius, y, -x - radius, y - radius);
    shape.lineTo(-x - radius, -y + radius);
    shape.quadraticCurveTo(-x - radius, -y, -x, -y);
    
    const extrudeSettings = {
        depth: depth,
        bevelEnabled: true,
        bevelSegments: smoothness, // 2-4 –¥–ª—è –±–∞–ª–∞–Ω—Å–∞ –∫–∞—á–µ—Å—Ç–≤–∞/–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        steps: 1,
        bevelSize: radius,
        bevelThickness: radius,
        curveSegments: smoothness * 4
    };
    
    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    geometry.translate(0, 0, -depth/2);
    return geometry;
}
2. –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏—è:
javascriptconst voxelSize = 0.3;     // –ë–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä
const roundness = 0.08;     // –†–∞–¥–∏—É—Å –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏—è (20-30% –æ—Ç —Ä–∞–∑–º–µ—Ä–∞)
const detail = 2;           // –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è (1-4, –≥–¥–µ 2 –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ)

// –î–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤:
const roundnessMap = {
    organic: voxelSize * 0.3,   // –ü—Ä–∏—Ä–æ–¥–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã - –±–æ–ª–µ–µ –º—è–≥–∫–∏–µ
    structural: voxelSize * 0.2, // –ó–¥–∞–Ω–∏—è - —Å—Ä–µ–¥–Ω–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–µ  
    decorative: voxelSize * 0.4  // –î–µ–∫–æ—Ä - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –º—è–≥–∫–∏–µ
};
3. –ú–∞—Ç–µ—Ä–∏–∞–ª—ã –¥–ª—è rounded voxels:
javascript// –ò—Å–ø–æ–ª—å–∑—É–π Phong –¥–ª—è –ª—É—á—à–∏—Ö –±–ª–∏–∫–æ–≤ –Ω–∞ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã—Ö –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—è—Ö
const material = new THREE.MeshPhongMaterial({ 
    color: color,
    shininess: 30,        // –ë–ª–∏–∫–∏ –Ω–∞ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã—Ö –≥—Ä–∞–Ω—è—Ö
    specular: 0x222222,   // –¶–≤–µ—Ç –±–ª–∏–∫–æ–≤
    emissive: 0x000000,   // –î–ª—è —Å–≤–µ—Ç—è—â–∏—Ö—Å—è –æ–±—ä–µ–∫—Ç–æ–≤
    emissiveIntensity: 0  // 0.5-0.7 –¥–ª—è –æ–≥–Ω—è
});
4. –ö–æ–º–∞–Ω–¥—ã –¥–ª—è Cursor —Å rounded voxels:
javascript// –ö–û–ú–ê–ù–î–ê: "–°–æ–∑–¥–∞–π rounded voxel –æ–±—ä–µ–∫—Ç"
"Create a rounded voxel object in THREE.js:
1. Use ExtrudeGeometry with Shape for rounded corners
2. Radius = 20-30% of voxel size for organic look
3. BevelSegments = 2 for performance, 4 for quality
4. Material: MeshPhongMaterial with shininess: 30
5. Add subtle size variations (0.9-1.1x) for organic feel"

// –ö–û–ú–ê–ù–î–ê: "–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è rounded voxels"
"Optimize rounded voxels:
1. Create single geometry, clone for instances
2. Use InstancedMesh for repeated voxels
3. Merge geometries with same material
4. LOD: reduce bevelSegments for distant objects"
5. –ü—Ä–∞–≤–∏–ª–∞ —Å—Ç–∏–ª–∏–∑–∞—Ü–∏–∏:
–û—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã (–¥–µ—Ä–µ–≤—å—è, –∫–∞–º–Ω–∏):
javascript// –í–∞—Ä–∏–∞—Ü–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏
const size = voxelSize * (0.8 + Math.random() * 0.4);
// –ë–æ–ª—å—à–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏—è
const radius = size * 0.35;
–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã:
javascript// –°—Ç–∞–±–∏–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä
const size = voxelSize;
// –£–º–µ—Ä–µ–Ω–Ω–æ–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ
const radius = size * 0.2;
–î–µ—Ç–∞–ª–∏ –∏ –∞–∫—Ü–µ–Ω—Ç—ã:
javascript// –ú–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏
const size = voxelSize * 0.5;
// –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–ª—è –º—è–≥–∫–æ—Å—Ç–∏
const radius = size * 0.4;
6. –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ rounded voxel —Å—Ç–∏–ª—è:

–ù–ï –¥–µ–ª–∞–π –æ—Å—Ç—Ä—ã–µ —É–≥–ª—ã - –≤—Å—ë –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –º—è–≥–∫–∏–º
–î–æ–±–∞–≤–ª—è–π –≤–∞—Ä–∏–∞—Ü–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ (¬±20%) –¥–ª—è –æ—Ä–≥–∞–Ω–∏—á–Ω–æ—Å—Ç–∏
–ò—Å–ø–æ–ª—å–∑—É–π Phong –º–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è –∫—Ä–∞—Å–∏–≤—ã—Ö –±–ª–∏–∫–æ–≤
–ì—Ä—É–ø–ø–∏—Ä—É–π –≤–æ–∫—Å–µ–ª–∏ —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
–≠–º–∏—Å—Å–∏—è –¥–ª—è —Å–≤–µ—Ç—è—â–∏—Ö—Å—è –æ–±—ä–µ–∫—Ç–æ–≤ (–æ–≥–æ–Ω—å, –ª–∞–º–ø—ã)

7. –ü—Ä–∏–º–µ—Ä –ø–æ–ª–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞:
javascriptfunction createRoundedTree() {
    const group = new THREE.Group();
    
    // –°—Ç–≤–æ–ª - –º–µ–Ω—å—à–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏—è
    for(let y = 0; y < 3; y++) {
        const geometry = createRoundedBox(
            voxelSize, voxelSize, voxelSize, 
            voxelSize * 0.15, 2
        );
        const trunk = new THREE.Mesh(geometry, trunkMaterial);
        trunk.position.y = y * voxelSize;
        group.add(trunk);
    }
    
    // –ö—Ä–æ–Ω–∞ - –±–æ–ª—å—à–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏—è –∏ –≤–∞—Ä–∏–∞—Ü–∏–π
    for(let y = 3; y < 10; y++) {
        // —Å–ª—É—á–∞–π–Ω—ã–µ –≤–∞—Ä–∏–∞—Ü–∏–∏ —Ä–∞–∑–º–µ—Ä–∞
        const variation = 0.8 + Math.random() * 0.4;
        const size = voxelSize * variation;
        const geometry = createRoundedBox(
            size, size, size,
            size * 0.35, 2
        );
        // –ø–æ–∑–∏—Ü–∏–∏ —Å –Ω–µ–±–æ–ª—å—à–∏–º —à—É–º–æ–º
        const crown = new THREE.Mesh(geometry, leafMaterial);
        crown.position.set(
            (Math.random() - 0.5) * voxelSize,
            y * voxelSize,
            (Math.random() - 0.5) * voxelSize
        );
        group.add(crown);
    }
    
    return group;
}3d Models
üìê –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –ü–†–ê–í–ò–õ–ê –î–õ–Ø ROUNDED VOXELS:
1. –ë–∞–∑–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω–æ–≥–æ –≤–æ–∫—Å–µ–ª—è:
javascript// –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø - –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–π –µ—ë!
function createRoundedBox(width, height, depth, radius, smoothness) {
    const shape = new THREE.Shape();
    const x = width / 2 - radius;
    const y = height / 2 - radius;
    
    // –†–∏—Å—É–µ–º –ø—Ä–æ—Ñ–∏–ª—å —Å –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–º–∏ —É–≥–ª–∞–º–∏
    shape.moveTo(-x, -y);
    shape.lineTo(x, -y);
    shape.quadraticCurveTo(x + radius, -y, x + radius, -y + radius);
    shape.lineTo(x + radius, y - radius);
    shape.quadraticCurveTo(x + radius, y, x, y);
    shape.lineTo(-x, y);
    shape.quadraticCurveTo(-x - radius, y, -x - radius, y - radius);
    shape.lineTo(-x - radius, -y + radius);
    shape.quadraticCurveTo(-x - radius, -y, -x, -y);
    
    const extrudeSettings = {
        depth: depth,
        bevelEnabled: true,
        bevelSegments: smoothness, // 2-4 –¥–ª—è –±–∞–ª–∞–Ω—Å–∞ –∫–∞—á–µ—Å—Ç–≤–∞/–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        steps: 1,
        bevelSize: radius,
        bevelThickness: radius,
        curveSegments: smoothness * 4
    };
    
    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    geometry.translate(0, 0, -depth/2);
    return geometry;
}
2. –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏—è:
javascriptconst voxelSize = 0.3;     // –ë–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä
const roundness = 0.08;     // –†–∞–¥–∏—É—Å –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏—è (20-30% –æ—Ç —Ä–∞–∑–º–µ—Ä–∞)
const detail = 2;           // –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è (1-4, –≥–¥–µ 2 –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ)

// –î–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤:
const roundnessMap = {
    organic: voxelSize * 0.3,   // –ü—Ä–∏—Ä–æ–¥–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã - –±–æ–ª–µ–µ –º—è–≥–∫–∏–µ
    structural: voxelSize * 0.2, // –ó–¥–∞–Ω–∏—è - —Å—Ä–µ–¥–Ω–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–µ  
    decorative: voxelSize * 0.4  // –î–µ–∫–æ—Ä - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –º—è–≥–∫–∏–µ
};
3. –ú–∞—Ç–µ—Ä–∏–∞–ª—ã –¥–ª—è rounded voxels:
javascript// –ò—Å–ø–æ–ª—å–∑—É–π Phong –¥–ª—è –ª—É—á—à–∏—Ö –±–ª–∏–∫–æ–≤ –Ω–∞ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã—Ö –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—è—Ö
const material = new THREE.MeshPhongMaterial({ 
    color: color,
    shininess: 30,        // –ë–ª–∏–∫–∏ –Ω–∞ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã—Ö –≥—Ä–∞–Ω—è—Ö
    specular: 0x222222,   // –¶–≤–µ—Ç –±–ª–∏–∫–æ–≤
    emissive: 0x000000,   // –î–ª—è —Å–≤–µ—Ç—è—â–∏—Ö—Å—è –æ–±—ä–µ–∫—Ç–æ–≤
    emissiveIntensity: 0  // 0.5-0.7 –¥–ª—è –æ–≥–Ω—è
});
4. –ö–æ–º–∞–Ω–¥—ã –¥–ª—è Cursor —Å rounded voxels:
javascript// –ö–û–ú–ê–ù–î–ê: "–°–æ–∑–¥–∞–π rounded voxel –æ–±—ä–µ–∫—Ç"
"Create a rounded voxel object in THREE.js:
1. Use ExtrudeGeometry with Shape for rounded corners
2. Radius = 20-30% of voxel size for organic look
3. BevelSegments = 2 for performance, 4 for quality
4. Material: MeshPhongMaterial with shininess: 30
5. Add subtle size variations (0.9-1.1x) for organic feel"

// –ö–û–ú–ê–ù–î–ê: "–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è rounded voxels"
"Optimize rounded voxels:
1. Create single geometry, clone for instances
2. Use InstancedMesh for repeated voxels
3. Merge geometries with same material
4. LOD: reduce bevelSegments for distant objects"
5. –ü—Ä–∞–≤–∏–ª–∞ —Å—Ç–∏–ª–∏–∑–∞—Ü–∏–∏:
–û—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã (–¥–µ—Ä–µ–≤—å—è, –∫–∞–º–Ω–∏):
javascript// –í–∞—Ä–∏–∞—Ü–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏
const size = voxelSize * (0.8 + Math.random() * 0.4);
// –ë–æ–ª—å—à–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏—è
const radius = size * 0.35;
–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã:
javascript// –°—Ç–∞–±–∏–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä
const size = voxelSize;
// –£–º–µ—Ä–µ–Ω–Ω–æ–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ
const radius = size * 0.2;
–î–µ—Ç–∞–ª–∏ –∏ –∞–∫—Ü–µ–Ω—Ç—ã:
javascript// –ú–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏
const size = voxelSize * 0.5;
// –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–ª—è –º—è–≥–∫–æ—Å—Ç–∏
const radius = size * 0.4;
6. –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ rounded voxel —Å—Ç–∏–ª—è:

–ù–ï –¥–µ–ª–∞–π –æ—Å—Ç—Ä—ã–µ —É–≥–ª—ã - –≤—Å—ë –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –º—è–≥–∫–∏–º
–î–æ–±–∞–≤–ª—è–π –≤–∞—Ä–∏–∞—Ü–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ (¬±20%) –¥–ª—è –æ—Ä–≥–∞–Ω–∏—á–Ω–æ—Å—Ç–∏
–ò—Å–ø–æ–ª—å–∑—É–π Phong –º–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è –∫—Ä–∞—Å–∏–≤—ã—Ö –±–ª–∏–∫–æ–≤
–ì—Ä—É–ø–ø–∏—Ä—É–π –≤–æ–∫—Å–µ–ª–∏ —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
–≠–º–∏—Å—Å–∏—è –¥–ª—è —Å–≤–µ—Ç—è—â–∏—Ö—Å—è –æ–±—ä–µ–∫—Ç–æ–≤ (–æ–≥–æ–Ω—å, –ª–∞–º–ø—ã)

7. –ü—Ä–∏–º–µ—Ä –ø–æ–ª–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞:
javascriptfunction createRoundedTree() {
    const group = new THREE.Group();
    
    // –°—Ç–≤–æ–ª - –º–µ–Ω—å—à–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏—è
    for(let y = 0; y < 3; y++) {
        const geometry = createRoundedBox(
            voxelSize, voxelSize, voxelSize, 
            voxelSize * 0.15, 2
        );
        const trunk = new THREE.Mesh(geometry, trunkMaterial);
        trunk.position.y = y * voxelSize;
        group.add(trunk);
    }
    
    // –ö—Ä–æ–Ω–∞ - –±–æ–ª—å—à–µ –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏—è –∏ –≤–∞—Ä–∏–∞—Ü–∏–π
    for(let y = 3; y < 10; y++) {
        // —Å–ª—É—á–∞–π–Ω—ã–µ –≤–∞—Ä–∏–∞—Ü–∏–∏ —Ä–∞–∑–º–µ—Ä–∞
        const variation = 0.8 + Math.random() * 0.4;
        const size = voxelSize * variation;
        const geometry = createRoundedBox(
            size, size, size,
            size * 0.35, 2
        );
        // –ø–æ–∑–∏—Ü–∏–∏ —Å –Ω–µ–±–æ–ª—å—à–∏–º —à—É–º–æ–º
        const crown = new THREE.Mesh(geometry, leafMaterial);
        crown.position.set(
            (Math.random() - 0.5) * voxelSize,
            y * voxelSize,
            (Math.random() - 0.5) * voxelSize
        );
        group.add(crown);
    }
    
    return group;
}